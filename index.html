<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>yoru no tsushin</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@200;300;400&display=swap" rel="stylesheet">

  <style>
    :root{
      --grid: 22px;
      --bg: #050724;

      --paper:#b9bcc4;
      --paper2:#aeb2bc;

      --line: rgba(0,0,255,.16);
      --lineStrong: rgba(0,0,255,.92);
      --shadow: rgba(0,0,0,.62);

      --txt: rgba(255,255,255,.22);
      --btnTxt: rgba(255,255,255,.28);
      --btnTxtOn: rgba(255,255,255,.55);
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background: var(--bg);
      overscroll-behavior:none;
    }

    .padWrap{
      width:min(92vw, 900px);
      height:min(78vh, 640px);
      display:grid;
      place-items:center;
    }

    .pad{
      width:100%;
      height:100%;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(185,188,196,.92), rgba(174,178,188,.90));
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.40),
        inset 0 -1px 0 rgba(0,0,0,.18),
        0 26px 90px var(--shadow);
      border:2px solid var(--lineStrong);
      position:relative;
      overflow:hidden;

      touch-action:none;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      -webkit-user-select:none;
    }

    .pad::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(0deg,  var(--line) 0 1px, transparent 1px var(--grid)),
        repeating-linear-gradient(90deg, var(--line) 0 1px, transparent 1px var(--grid));
      pointer-events:none;
      opacity:1;
    }

    .slab{
      position:absolute;
      left:-80px;
      bottom:-180px;
      width:130%;
      height:130%;
      pointer-events:none;
      opacity:.10;
      transform: skewX(-10deg);
      background:
        radial-gradient(closest-side at 30% 70%, rgba(0,0,255,.75), transparent 62%),
        radial-gradient(closest-side at 55% 75%, rgba(0,0,255,.55), transparent 64%),
        radial-gradient(closest-side at 70% 40%, rgba(0,0,255,.45), transparent 60%);
      mix-blend-mode:multiply;
      filter: blur(.2px);
    }

    .ghost{
      position:absolute;
      top:12px;
      right:14px;
      font-family:"Oxanium", ui-monospace, monospace;
      font-weight:200;
      letter-spacing:3.5px;
      text-transform: lowercase;
      font-size:15px;
      color: var(--txt);
      pointer-events:none;
      mix-blend-mode: screen;
    }

    .dot{
      position:absolute;
      width:12px; height:12px;
      border-radius:999px;
      background: rgba(0,0,255,.92);
      box-shadow: 0 0 16px rgba(0,0,255,.25);
      border:1px solid rgba(255,255,255,.38);
      transform: translate(-50%,-50%);
      pointer-events:none;
      opacity:.92;
    }
    .dot.dot2{
      width:10px; height:10px;
      opacity:.75;
      background: rgba(0,0,255,.70);
      box-shadow: 0 0 12px rgba(0,0,255,.20);
    }

    /* ★触れてない時は完全に消す */
    .dot.hidden{ display:none; }

    /* LOOP button */
    .loopBtn{
      position:absolute;
      left:14px;
      bottom:14px;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(0,0,255,.55);
      background: rgba(255,255,255,.06);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.20),
        inset 0 -1px 0 rgba(0,0,0,.12);
      font-family:"Oxanium", ui-monospace, monospace;
      font-weight:300;
      letter-spacing:2.4px;
      text-transform: lowercase;
      color: var(--btnTxt);
      cursor:pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      -webkit-user-select:none;
    }
    .loopBtn:active{
      transform: translateY(1px);
    }
    .loopBtn.on{
      border-color: rgba(0,0,255,.95);
      background: rgba(0,0,255,.12);
      color: var(--btnTxtOn);
      box-shadow:
        0 0 18px rgba(0,0,255,.18),
        inset 0 1px 0 rgba(255,255,255,.22),
        inset 0 -1px 0 rgba(0,0,0,.12);
    }
  </style>
</head>

<body>
  <div class="padWrap">
    <div class="pad" id="pad" aria-label="xy pad">
      <div class="slab" aria-hidden="true"></div>
      <div class="ghost" aria-hidden="true">yoru no tsushin</div>

      <button class="loopBtn" id="loopBtn" aria-label="loop">loop</button>

      <div class="dot hidden" id="dot1"></div>
      <div class="dot dot2 hidden" id="dot2"></div>
    </div>
  </div>

<script>
/* =========================================================
   yoru no tsushin — PRO / 2-touch / mobile-hardened + LOOP latch
========================================================= */

const pad = document.getElementById("pad");
const loopBtn = document.getElementById("loopBtn");
const dot1 = document.getElementById("dot1");
const dot2 = document.getElementById("dot2");

/* ranges */
const MIN_MS = 60;
const MAX_MS = 1800;
const PITCH_MIN_MULT = 0.35;
const PITCH_MAX_MULT = 3.00;

/* levels */
const MASTER_LEVEL = 0.096;
const BUG_LEVEL = 0.20;

/* probabilities */
const NOISE_PROB  = 1/15;
const GLITCH_PROB = 1/12;

/* chord tones: Fmaj7(9) = F A C E G */
const MID = [
  { hz: 349.228 },
  { hz: 440.000 },
  { hz: 523.251 },
  { hz: 659.255 },
  { hz: 783.991 },
];

function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function pickRandomNote(){ return MID[(Math.random() * MID.length) | 0]; }

function yToMult(y){
  const t = 1 - y;
  const shaped = Math.pow(t, 1.15);
  return PITCH_MIN_MULT * Math.pow(PITCH_MAX_MULT / PITCH_MIN_MULT, shaped);
}
function xToMs(x){
  const shaped = Math.pow(1 - x, 1.25);
  return MIN_MS + (MAX_MS - MIN_MS) * shaped;
}
function msToLfoHz(ms){ return 500 / ms; }

/* ===== audio state ===== */
let ctx = null;
let master = null, comp = null;
let iosUnlocked = false;

let voice1 = null, voice2 = null;
let noiseGain = null, noiseSrc = null;
let glitchBus = null;

let whiteBuf=null, pinkBuf=null, digiBuf=null;

let holding = false;
let bugNoise = false;

/* LOOP latch */
let latched = false;         // loop button state
let latchedTouchCount = 1;   // remember 1 or 2 voices when latched
let lastXY1 = {x01:0.5, y01:0.5};
let lastXY2 = {x01:0.5, y01:0.5};

/* ===== geometry ===== */
let padRect = null;
function updateRect(){ padRect = pad.getBoundingClientRect(); }
updateRect();
window.addEventListener("resize", updateRect, {passive:true});
window.addEventListener("scroll", updateRect, {passive:true});

const active = new Map(); // pointerId -> {x01,y01,lastTs}

function getXY01(clientX, clientY){
  if (!padRect) updateRect();
  const x01 = clamp01((clientX - padRect.left) / padRect.width);
  const y01 = clamp01((clientY - padRect.top)  / padRect.height);
  return {x01,y01};
}

function syncDots(){
  const ids = Array.from(active.keys()).slice(0,2);
  const a = ids[0] ? active.get(ids[0]) : null;
  const b = ids[1] ? active.get(ids[1]) : null;

  if (a){
    dot1.classList.remove("hidden");
    dot1.style.left = (a.x01 * padRect.width) + "px";
    dot1.style.top  = (a.y01 * padRect.height) + "px";
  } else {
    dot1.classList.add("hidden");
  }

  if (b){
    dot2.classList.remove("hidden");
    dot2.style.left = (b.x01 * padRect.width) + "px";
    dot2.style.top  = (b.y01 * padRect.height) + "px";
  } else {
    dot2.classList.add("hidden");
  }
}

/* ===== helpers ===== */
function ramp(param, value, t=0.02){
  if (!ctx) return;
  const now = ctx.currentTime;
  param.cancelScheduledValues(now);
  param.setValueAtTime(param.value, now);
  param.linearRampToValueAtTime(value, now + t);
}

function ensureNoiseBuffers(){
  if (whiteBuf) return;
  const sr = ctx.sampleRate;

  const makeWhite = (sec=2) => {
    const len = Math.floor(sr * sec);
    const buf = ctx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    for (let i=0;i<len;i++) d[i] = (Math.random()*2 - 1);
    return buf;
  };
  const makePinkish = (sec=2) => {
    const len = Math.floor(sr * sec);
    const buf = ctx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    let y=0, a=0.985;
    for (let i=0;i<len;i++){
      const x = (Math.random()*2 - 1);
      y = a*y + (1-a)*x;
      d[i] = y * 1.6;
    }
    return buf;
  };
  const makeDigital = (sec=2) => {
    const len = Math.floor(sr * sec);
    const buf = ctx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    const holdMin=6, holdMax=80;
    let v=0, n=0;
    for (let i=0;i<len;i++){
      if (n<=0){
        v = (Math.random()*2 - 1);
        n = (holdMin + ((Math.random()*(holdMax-holdMin))|0));
      }
      d[i]=v; n--;
    }
    return buf;
  };

  whiteBuf = makeWhite(2);
  pinkBuf  = makePinkish(2);
  digiBuf  = makeDigital(2);
}

function startNoise(type){
  ensureNoiseBuffers();
  stopNoise();
  noiseSrc = ctx.createBufferSource();
  noiseSrc.loop = true;
  noiseSrc.buffer = (type===0) ? whiteBuf : (type===1) ? pinkBuf : digiBuf;
  noiseSrc.connect(noiseGain);
  noiseSrc.start();
}

function stopNoise(){
  if (!noiseSrc) return;
  try{ noiseSrc.stop(); }catch(e){}
  try{ noiseSrc.disconnect(); }catch(e){}
  noiseSrc = null;
}

/* ===== voice ===== */
function makeGateShaper(){
  const sh = ctx.createWaveShaper();
  const N = 1024;
  const curve = new Float32Array(N);
  for (let i=0;i<N;i++){
    const x = (i/(N-1))*2-1;
    curve[i] = x >= 0 ? 1 : 0;
  }
  sh.curve = curve;
  sh.oversample = "4x";
  return sh;
}

function makeVoice(){
  const v = {};
  v.note = pickRandomNote();

  v.osc = ctx.createOscillator();
  v.osc.type = "sine";
  v.osc.frequency.value = v.note.hz;

  v.toneGain = ctx.createGain();
  v.toneGain.gain.value = 0.0;

  v.gateGain = ctx.createGain();
  v.gateGain.gain.value = 0.0;

  v.out = ctx.createGain();
  v.out.gain.value = 0.0;

  v.lfo = ctx.createOscillator();
  v.lfo.type = "square";
  v.lfo.frequency.value = msToLfoHz(400);

  v.shaper = makeGateShaper();
  v.lfoDepth = ctx.createGain();
  v.lfoDepth.gain.value = 0.0;

  v.osc.connect(v.toneGain);
  v.toneGain.connect(v.gateGain);
  v.gateGain.connect(v.out);
  v.out.connect(master);

  v.lfo.connect(v.shaper);
  v.shaper.connect(v.lfoDepth);
  v.lfoDepth.connect(v.gateGain.gain);

  v.osc.start();
  v.lfo.start();

  return v;
}

function setVoiceFromXY(v, x01, y01){
  if (!ctx) return;
  const mult = yToMult(y01);
  const ms = xToMs(x01);
  const det = 1 + (Math.random()*0.002 - 0.001);
  v.osc.frequency.value = (v.note.hz * mult) * det;
  v.lfo.frequency.value = msToLfoHz(ms);
}

/* ===== audio init / hard resume ===== */
function ensureAudio(){
  if (ctx) return;

  ctx = new (window.AudioContext || window.webkitAudioContext)();

  master = ctx.createGain();
  master.gain.value = 0.0;

  comp = ctx.createDynamicsCompressor();
  comp.threshold.value = -18;
  comp.knee.value = 10;
  comp.ratio.value = 6;
  comp.attack.value = 0.004;
  comp.release.value = 0.08;

  master.connect(comp);
  comp.connect(ctx.destination);

  noiseGain = ctx.createGain();
  noiseGain.gain.value = 0.0;
  noiseGain.connect(master);

  glitchBus = ctx.createGain();
  glitchBus.gain.value = BUG_LEVEL;
  glitchBus.connect(master);

  voice1 = makeVoice();
  voice2 = makeVoice();
}

function unlockIOSOnce(){
  if (!ctx || iosUnlocked) return;
  try{
    const buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    src.connect(ctx.destination);
    src.start(0);
    src.stop(0.01);
    iosUnlocked = true;
  }catch(e){}
}

async function hardResumeAudio(){
  if (!ctx) ensureAudio();
  try { await ctx.resume(); } catch(e) {}

  if (ctx && ctx.state !== "running"){
    try { await ctx.close(); } catch(e) {}
    ctx = null; master = null; comp = null;
    voice1 = null; voice2 = null;
    noiseGain = null; glitchBus = null;
    noiseSrc = null;
    iosUnlocked = false;
    whiteBuf = pinkBuf = digiBuf = null;

    ensureAudio();
    unlockIOSOnce();
    try { await ctx.resume(); } catch(e) {}
  }

  try{
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    g.gain.value = 0.002;
    o.frequency.value = 440;
    o.connect(g); g.connect(ctx.destination);
    o.start();
    o.stop(ctx.currentTime + 0.02);
  }catch(e){}
}

/* ===== SF UI beep ===== */
function playGlitchOneShot(type){
  if (!ctx) return;
  const now = ctx.currentTime;

  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0, now);
  g.connect(glitchBus);

  function cleanup(at){
    g.gain.linearRampToValueAtTime(0.0, at);
    setTimeout(() => { try { g.disconnect(); } catch(e){} }, Math.max(0, (at-now)*1000 + 80));
  }

  const click = ctx.createBufferSource();
  const clickBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate*0.02), ctx.sampleRate);
  const cd = clickBuf.getChannelData(0);
  for (let i=0;i<cd.length;i++){
    const t = i / cd.length;
    cd[i] = (Math.random()*2-1) * Math.exp(-t*18);
  }
  click.buffer = clickBuf;

  const bp = ctx.createBiquadFilter();
  bp.type = "bandpass";
  bp.frequency.setValueAtTime(2200, now);
  bp.Q.setValueAtTime(10, now);

  const clickGain = ctx.createGain();
  clickGain.gain.setValueAtTime(0.0, now);
  clickGain.gain.linearRampToValueAtTime(0.45, now + 0.001);
  clickGain.gain.exponentialRampToValueAtTime(0.0008, now + 0.018);

  click.connect(bp); bp.connect(clickGain); clickGain.connect(g);

  const o1 = ctx.createOscillator();
  const o2 = ctx.createOscillator();
  o1.type = "sine";
  o2.type = "triangle";

  const fm = ctx.createOscillator();
  fm.type = "sine";
  const fmGain = ctx.createGain();
  fmGain.gain.setValueAtTime(0.0, now);
  fm.connect(fmGain);
  fmGain.connect(o1.frequency);

  const toneGain = ctx.createGain();
  toneGain.gain.setValueAtTime(1.0, now);
  toneGain.connect(g);

  o1.connect(toneGain);
  o2.connect(toneGain);

  const A = 0.002, D = 0.060;
  g.gain.linearRampToValueAtTime(1.0, now + A);
  g.gain.exponentialRampToValueAtTime(0.0008, now + A + D);

  if (type === 0){
    o1.frequency.setValueAtTime(1800, now);
    o1.frequency.exponentialRampToValueAtTime(8200, now + 0.060);
    o2.frequency.setValueAtTime(1200, now);
    o2.frequency.exponentialRampToValueAtTime(3600, now + 0.060);
    fm.frequency.setValueAtTime(70, now);
    fmGain.gain.setValueAtTime(55, now);
    cleanup(now + 0.080);
  } else if (type === 1){
    o1.frequency.setValueAtTime(9500, now);
    o1.frequency.exponentialRampToValueAtTime(2600, now + 0.055);
    o2.frequency.setValueAtTime(4800, now);
    o2.frequency.exponentialRampToValueAtTime(1600, now + 0.055);
    fm.frequency.setValueAtTime(55, now);
    fmGain.gain.setValueAtTime(40, now);
    cleanup(now + 0.075);
  } else if (type === 2){
    o1.frequency.setValueAtTime(5200, now);
    o2.frequency.setValueAtTime(2600, now);

    toneGain.gain.setValueAtTime(0.0, now);
    toneGain.gain.linearRampToValueAtTime(1.0, now + 0.002);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + 0.028);

    toneGain.gain.setValueAtTime(0.0, now + 0.040);
    toneGain.gain.linearRampToValueAtTime(1.0, now + 0.042);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + 0.070);

    fm.frequency.setValueAtTime(90, now);
    fmGain.gain.setValueAtTime(20, now);
    cleanup(now + 0.090);
  } else if (type === 3){
    o1.frequency.setValueAtTime(3400, now);
    o1.frequency.linearRampToValueAtTime(3800, now + 0.018);
    o1.frequency.linearRampToValueAtTime(3300, now + 0.045);

    o2.frequency.setValueAtTime(1700, now);
    o2.frequency.linearRampToValueAtTime(1900, now + 0.018);
    o2.frequency.linearRampToValueAtTime(1650, now + 0.045);

    fm.frequency.setValueAtTime(120, now);
    fmGain.gain.setValueAtTime(35, now);
    cleanup(now + 0.070);
  } else {
    bp.frequency.setValueAtTime(2800, now);
    bp.frequency.linearRampToValueAtTime(1400, now + 0.020);

    o1.frequency.setValueAtTime(2400, now);
    o1.frequency.exponentialRampToValueAtTime(7200, now + 0.040);
    o2.frequency.setValueAtTime(900, now);
    o2.frequency.exponentialRampToValueAtTime(2100, now + 0.040);

    fm.frequency.setValueAtTime(45, now);
    fmGain.gain.setValueAtTime(75, now);
    cleanup(now + 0.085);
  }

  click.start(now);
  fm.start(now);
  o1.start(now);
  o2.start(now);

  setTimeout(() => {
    try{ click.stop(); fm.stop(); o1.stop(); o2.stop(); }catch(e){}
    try{ click.disconnect(); bp.disconnect(); clickGain.disconnect(); }catch(e){}
    try{ fmGain.disconnect(); toneGain.disconnect(); }catch(e){}
  }, 220);
}

/* ===== core apply ===== */
function applyVoicesFromActive(){
  const ids = Array.from(active.keys()).slice(0,2);
  const a = ids[0] ? active.get(ids[0]) : null;
  const b = ids[1] ? active.get(ids[1]) : null;

  if (a && voice1){
    lastXY1 = {x01:a.x01, y01:a.y01};
    setVoiceFromXY(voice1, a.x01, a.y01);
  }
  if (b && voice2){
    lastXY2 = {x01:b.x01, y01:b.y01};
    setVoiceFromXY(voice2, b.x01, b.y01);
  }
}

function applyVoicesFromLatched(){
  if (!voice1 || !voice2) return;
  setVoiceFromXY(voice1, lastXY1.x01, lastXY1.y01);
  if (latchedTouchCount >= 2){
    setVoiceFromXY(voice2, lastXY2.x01, lastXY2.y01);
  }
}

function setMixForTouchCount(n){
  if (!ctx || !voice1 || !voice2) return;
  const v = (n >= 2) ? 0.60 : 0.85;
  ramp(voice1.out.gain, (n>=1) ? v : 0.0, 0.02);
  ramp(voice2.out.gain, (n>=2) ? v : 0.0, 0.02);
}

async function startIfNeeded(){
  ensureAudio();
  unlockIOSOnce();
  await hardResumeAudio();
  if (!ctx || ctx.state !== "running") return;
  if (holding) return;

  holding = true;

  voice1.note = pickRandomNote();
  voice2.note = pickRandomNote();

  if (Math.random() < GLITCH_PROB){
    playGlitchOneShot((Math.random()*5)|0);
  }

  bugNoise = (Math.random() < NOISE_PROB);
  if (bugNoise){
    const bugType = (Math.random()*3)|0;
    startNoise(bugType);
    ramp(noiseGain.gain, BUG_LEVEL, 0.02);
    ramp(voice1.toneGain.gain, 0.0, 0.02);
    ramp(voice2.toneGain.gain, 0.0, 0.02);
  } else {
    stopNoise();
    ramp(noiseGain.gain, 0.0, 0.02);
    ramp(voice1.toneGain.gain, 1.0, 0.02);
    ramp(voice2.toneGain.gain, 1.0, 0.02);
  }

  ramp(voice1.lfoDepth.gain, 1.0, 0.02);
  ramp(voice2.lfoDepth.gain, 1.0, 0.02);

  ramp(master.gain, MASTER_LEVEL, 0.02);

  applyVoicesFromActive();
  setMixForTouchCount(Math.min(2, active.size) || 1);
}

function stopIfNeeded(){
  if (!holding) return;
  holding = false;

  if (!ctx) return;

  ramp(master.gain, 0.0, 0.05);
  if (voice1) ramp(voice1.lfoDepth.gain, 0.0, 0.03);
  if (voice2) ramp(voice2.lfoDepth.gain, 0.0, 0.03);

  setTimeout(() => {
    if (!holding) stopNoise();
  }, 140);
}

/* ===== LOOP button behavior =====
   - Only allowed to turn ON while holding (touching / sounding)
   - Turn OFF anytime; if no touches, stop
*/
function setLatch(on){
  latched = on;
  loopBtn.classList.toggle("on", latched);

  if (latched){
    // memorize how many voices were active at latch time (1 or 2)
    latchedTouchCount = Math.max(1, Math.min(2, active.size));
    // keep mix for latched voices
    setMixForTouchCount(latchedTouchCount);
    // keep last XY stable
    applyVoicesFromLatched();
  } else {
    // if nobody is touching, stop immediately
    if (active.size === 0) stopIfNeeded();
  }
}

loopBtn.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  e.stopPropagation();

  // ON: only while holding (i.e. currently sounding)
  if (!latched){
    if (!holding) return;
    setLatch(true);
  } else {
    setLatch(false);
  }
}, {passive:false});

/* ===== mobile recovery ===== */
window.addEventListener("pointerdown", () => { hardResumeAudio(); }, {capture:true, passive:true});
window.addEventListener("touchstart",  () => { hardResumeAudio(); }, {capture:true, passive:true});
document.addEventListener("visibilitychange", () => { if (!document.hidden) hardResumeAudio(); });
window.addEventListener("pageshow", () => { hardResumeAudio(); });

window.addEventListener("blur", () => {
  active.clear();
  syncDots();
  setLatch(false);
  stopIfNeeded();
});

/* ===== pointer events ===== */
pad.addEventListener("pointerdown", (e) => {
  // if loop button gets the event, it stopped propagation already
  e.preventDefault();
  updateRect();

  if (!active.has(e.pointerId) && active.size >= 2) return;

  const {x01,y01} = getXY01(e.clientX, e.clientY);
  active.set(e.pointerId, {x01,y01, lastTs: performance.now()});

  try { pad.setPointerCapture(e.pointerId); } catch(_){}

  syncDots();

  // touching while latched: keep latched ON, but update lastXY and voices
  startIfNeeded();
  applyVoicesFromActive();
  setMixForTouchCount(Math.min(2, active.size));
}, {passive:false});

pad.addEventListener("pointermove", (e) => {
  if (!active.has(e.pointerId)) return;
  e.preventDefault();

  const {x01,y01} = getXY01(e.clientX, e.clientY);
  const o = active.get(e.pointerId);
  o.x01 = x01; o.y01 = y01; o.lastTs = performance.now();

  syncDots();

  if (holding){
    applyVoicesFromActive();
  }
}, {passive:false});

function endPointer(e){
  if (!active.has(e.pointerId)) return;
  e.preventDefault();

  active.delete(e.pointerId);
  syncDots();

  // if no touches left:
  if (active.size === 0){
    if (latched){
      // keep sounding (no dots)
      applyVoicesFromLatched();
      setMixForTouchCount(latchedTouchCount);
      return;
    }
    stopIfNeeded();
    return;
  }

  // still touching with another finger
  applyVoicesFromActive();
  setMixForTouchCount(Math.min(2, active.size));
}

pad.addEventListener("pointerup", endPointer, {passive:false});
pad.addEventListener("pointercancel", endPointer, {passive:false});

/* init */
syncDots();
</script>
</body>
</html>
